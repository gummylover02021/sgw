-- Replace the external Maid load with this fixed version:
local Signal = loadstring(game:HttpGet("https://raw.githubusercontent.com/gummylover02021/sgw/refs/heads/main/Signal"))();

-- FIND getServerConstant FIRST
local getServerConstant = getgenv().getServerConstant

if not getServerConstant then
    print("[Maid] Searching for constants table...")
    
    local constantsTable = nil
    
    for _, tbl in pairs(getgc(true)) do
        if typeof(tbl) == 'table' then
            local ok, result = pcall(function()
                local hasTable = rawget(tbl, 'table')
                local hasFunc = rawget(tbl, 'function')
                local hasThread = rawget(tbl, 'thread')
                
                return hasTable and hasFunc and hasThread 
                    and hasTable ~= 'table' 
                    and hasFunc ~= 'function'
            end)
            
            if ok and result then
                constantsTable = tbl
                print("[Maid] ✓ Found constants table")
                break
            end
        end
    end
    
    if constantsTable then
        getServerConstant = function(key)
            return rawget(constantsTable, key) or key
        end
        getgenv().getServerConstant = getServerConstant
        print("[Maid] ✓ getServerConstant created")
    else
        warn("[Maid] ✗ Constants table not found, using fallback")
        getServerConstant = function(key) return key end
        getgenv().getServerConstant = getServerConstant
    end
end

local tableStr = getServerConstant('table');
local classNameStr = getServerConstant('Maid');
local funcStr = getServerConstant('function');
local threadStr = getServerConstant('thread');

local Maid = {}
Maid.ClassName = "Maid"

function Maid.new()
    return setmetatable({
        _tasks = {}
    }, Maid)
end

function Maid.isMaid(value)
    return type(value) == tableStr and value.ClassName == classNameStr
end

function Maid.__index(self, index)
    if Maid[index] then
        return Maid[index]
    else
        return self._tasks[index]
    end
end

-- FIXED: Better cleanup handling
function Maid:__newindex(index, newTask)
    if Maid[index] ~= nil then
        error(("'%s' is reserved"):format(tostring(index)), 2)
    end

    local tasks = self._tasks
    local oldTask = tasks[index]

    if oldTask == newTask then
        return
    end

    tasks[index] = newTask

    if oldTask then
        if type(oldTask) == "function" then
            oldTask()
        elseif typeof(oldTask) == "RBXScriptConnection" then
            oldTask:Disconnect()
        elseif Signal.isSignal(oldTask) then
            oldTask:Destroy()
        elseif typeof(oldTask) == 'thread' then
            task.cancel(oldTask)
        elseif typeof(oldTask) == 'table' then
            -- FIX: Check for Remove, Destroy, or Disconnect methods
            if oldTask.Remove then
                oldTask:Remove()
            elseif oldTask.Destroy then
                oldTask:Destroy()
            elseif oldTask.Disconnect then
                oldTask:Disconnect()
            end
        elseif oldTask.Destroy then
            oldTask:Destroy()
        end
    end
end

function Maid:GiveTask(task)
    if not task then
        error("Task cannot be false or nil", 2)
    end

    local taskId = #self._tasks+1
    self[taskId] = task

    return taskId
end

-- FIXED: Better cleanup in DoCleaning
function Maid:DoCleaning()
    local tasks = self._tasks

    -- Disconnect all events first as we know this is safe
    for index, task in pairs(tasks) do
        if typeof(task) == "RBXScriptConnection" then
            tasks[index] = nil
            task:Disconnect()
        end
    end

    -- Clear out tasks table completely
    local index, taskData = next(tasks)
    while taskData ~= nil do
        tasks[index] = nil
        
        if type(taskData) == funcStr then
            taskData()
        elseif typeof(taskData) == "RBXScriptConnection" then
            taskData:Disconnect()
        elseif Signal.isSignal(taskData) then
            taskData:Destroy()
        elseif typeof(taskData) == 'thread' then
            task.cancel(taskData)
        elseif typeof(taskData) == tableStr then
            -- FIX: Check for Remove, Destroy, or Disconnect methods
            if taskData.Remove then
                taskData:Remove()
            elseif taskData.Destroy then
                taskData:Destroy()
            elseif taskData.Disconnect then
                taskData:Disconnect()
            end
        elseif taskData.Destroy then
            taskData:Destroy()
        end
        
        index, taskData = next(tasks)
    end
end

Maid.Destroy = Maid.DoCleaning

-- Now assign to the variable
local Maid = Maid
